<!DOCTYPE html>
<meta charset=utf-8>
<title>Detekujeme podporu HTML5 - Dive Into HTML5</title>
<!--[if lt IE 9]><script src=j/html5.js></script><![endif]-->
<link rel=alternate type=application/atom+xml href=https://github.com/diveintomark/diveintohtml5/commits/master.atom>
<link rel=stylesheet href=screen.css>
<style>
body{counter-reset:h1 2}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=prefetch href=index.html>
<p>You are here: <a href=index.html>Home</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#detect>Dive Into <abbr>HTML5</abbr></a> <span class=u>&#8227;</span>
<h1><br>Detekujeme podporu <abbr>HTML5</abbr></h1>
<p id=toc>&nbsp;
<p class=a>&#x2767;
<h2 id=divingin>Jdeme na to</h2>

<p class=f><img src=i/aoc-m.png alt=M width=109 height=105>ohli byste se ptát: &#8222;Jak můžu používat <abbr>HTML5</abbr>, když ho starší prohlížeče nepodporují?&#8221; Ale byla by to zavádějící otázka. <abbr>HTML5</abbr> se skládá z řady částí. Nemůžete proto detekovat, zda prohlížeč &#8222;podporuje <abbr>HTML5</abbr>&#8221;, protože by to nedávalo žádný smysl. Ovšem <em>můžete</em> detekovat podporu jednotlivých částí (vlastností) HTML5, např. zda prohlížeč podporuje canvas, video nebo geolokaci.

<p class=a>&#x2767;

<h2 id=techniques>Techniky detekce</h2>

<p>Když prohlížeč vykresluje webovou stránku, vytvoří Document Object Model (<abbr><dfn>DOM</dfn></abbr>), což je kolekce objektů, které představují jednotlivé <abbr>HTML</abbr> prvky stránky. Každý prvek &mdash; každý <code>&lt;p></code>, každý <code>&lt;div></code>, každý <code>&lt;span></code> &mdash; je v <abbr>DOM</abbr>u zvláštním objektem. (Existujé také globální objekty, např. <code>window</code> a <code>document</code>, které se nevztahují k žádnému konkrétnímu prvku stránky.)

<p class=ss style="width:257px"><img src=i/openclipart.org_johnny_automatic_peeking_out_the_window.png width=257 height=436 alt="děvčátko, které se dívá z okna">

<p>Všechny objekty <abbr>DOM</abbr>u sdílí sadu společných vlastností, ovšem některé objekty mají některé vlastnosti navíc. V prohlížečích, které podporují vlastnosti <abbr>HTML5</abbr>, budou mít některé objekty unikátní vlastnosti. Rychlých pohledem na <abbr>DOM</abbr> tak zjistíme, které vlastnosti prohlížeč podporuje.

<p>Existují čtyři základní techniky detekující konkrétní vlastnost v tom kterém prohlížeči. Ukážeme si je od nejjednodušší po tu nejsložitější:

<ol>
<li>
<p>Ověřte, zda existuje jistá vlastnost globálního objektu (např. <code>window</code> nebo <code>navigator</code>).
<p>Příklad: <a href=#geolocation>test podpory geolokace</a>
<li>
<p>Vytvořte HTML prvek a ověřte, zda u něj existuje jistá vlastnost.
<p>Příklad: <a href=#canvas>text podpory canvasu</a>
<li>
<p>Vytvořte HTML prvek, ověřte, zda u něj existuje jistá metoda, zavolejte ji a zkontrolujte návratovou hodnotu.
<p>Příklad: <a href=#video-formats>test podporovaných formátů videa</a>
<li>
<p>Vytvořte HTML prvek, nastavte něj vlastnost na jistou hodnotu a pak zkontrolujte, zda si vlastnost tuto hodnotu uchovala.
<p>Příklad: <a href=#input-types>text podporovaných typů značky <code>&lt;input></code></a>
</ol>

<p class=a>&#x2767;

<h2 id=modernizr>Modernizr, knihovna pro detekci HTML5</h2>

<p><a href=http://www.modernizr.com/>Modernizr</a> je javascriptové open source knihonva (pod licencí <abbr>MIT</abbr>), která slouží k detekci řady vlastností <abbr>HTML5</abbr> <i class=baa>&amp;</i> <abbr>CSS3</abbr>. Měly byste vždy používat její nejnovější verzi. Pokud ji chcete použít, přidejte následující prvek <code>&lt;script></code> na začátek vaší webové stránky.

<pre style="float:left"><code>&lt;!DOCTYPE html>
&lt;html>
&lt;head>
  &lt;meta charset="utf-8">
  &lt;title>Dive Into HTML5&lt;/title>
  <mark>&lt;script src="modernizr.min.js">&lt;/script></mark>
&lt;/head>
&lt;body>
  ...
&lt;/body>
&lt;/html>
</code></pre>
<p class="legend right" style="margin-top:7em"><span class=arrow>&nbsp;&#x219c;</span> Vložte do &lt;head>

<p class=clear>Modernizr se spouští automaticky. Nemusíte proto volat žádnou metodu typu <code>modernizr_init()</code>. Jakmile se spustí, vytvoří globální objekt jmenující se <code>Modernizr</code>, který obsahuje sadu logických (Boolean) vlastností pro každou detekovanou vlastnost. Například, pokud váš prohlížeč podporuje <a href=canvas.html>canvas <abbr>API</abbr></a>, tak vlastnost <code>Modernizr.canvas</code> bude rovna <code>true</code>. Pokud váš prohlížeč canvas <abbr>API</abbr> nepodporuje, tak bude vlastnost <code>Modernizr.canvas</code> mít hodnotu <code>false</code>.

<pre><code>if (Modernizr.canvas) {
  // něco honem nakreslíme!
} else {
  // žádná podpora canvasu 8-(
}</code></pre>

<p class=a>&#x2767;

<h2 id=canvas>Canvas</h2>

<p class=ss style="width:300px"><img src=i/openclipart.org_johnny_automatic_fishing_boat.png width=300 height=203 alt="muž rybařící na loďce"><br><span id=live-canvas></span>

<p><abbr>HTML5</abbr> definuje <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html>prvek &lt;canvas></a> jako &#8222;na rozlišení závislé plátno, které lze použít pro vykreslení grafů, herní grafiky nebo jiných obrázků <i>za běhu</i>.&#8221; Prvek <dfn>canvas</dfn> vytvoří na vaší stránce obdélník, do kterého můžete JavaScriptem nakreslit, cokoliv si budete přát. <abbr>HTML5</abbr> definuje sadu funkcí (&#8222;the canvas <abbr>API</abbr>&#8221;) pro kreslení tvarů, definování cest, tvorbu gradientů a používání transformací.

<p>Test podpory canvas <abbr>API</abbr> použivá <a href=#techniques>detekční techniku #2</a>. Pokud váš prohlížeč podoruje canvas <abbr>API</abbr>, pak objekt <abbr>DOM</abbr> reprezentující vytvořený prvek <code>&lt;canvas></code> bude obsahovat <a href=canvas.html#shapes>metodu <code>getContext()</code></a>. Pokud váš pohlížeč canvas <abbr>API</abbr> nepodporuje, tak objekt <abbr>DOM</abbr> reprezentující vytvořený prvek <code>&lt;canvas></code> bude mít pouze sadu běžných vlastností, ovšem žádnou z těch specifických pro canvas.

<pre><code>function supports_canvas() {
  return !!document.createElement('canvas').getContext;
}
</code></pre>

<p>Tato funkce nejprve vytvoří prázdný prvek <code>&lt;canvas></code>, který ovšem není přidán do vaší stránky, takže jej nikdy nikdo neuvidí. Je pouze vytovřený v paměti a plave si odnikud nikam jako loďka po líné řece.

<pre><code>return !!document.<mark>createElement('canvas')</mark>.getContext;</code></pre>

<p>Na vytvořeném prázdném prvku <code>&lt;canvas></code> otestujeme přítomnost metody <code>getContext()</code>. Tuto metodu najdeme pouze v prohlížečích podporujících canvas <abbr>API</abbr>.

<pre><code>return !!document.createElement('canvas').<mark>getContext</mark>;</code></pre>

<p>A konečně, použijeme fintu dvojí negace, abychom jako návratovou hodnotu funkce získali logickou hodnotu (<code>true</code> nebo <code>false</code>).

<pre><code>return <mark>!!</mark>document.createElement('canvas').getContext;</code></pre>

<p>Tato funkce ověří podporu velké části canvas <abbr>API</abbr>, což zahrduje <a href=canvas.html#shapes>tvary</a>, <a href=canvas.html#paths>cesty</a>, <a href=canvas.html#gradients>gradienty <i class=baa>&amp;</i> vzory</a>. Nedokáže detekovat knihovny třetích stran jako je knihovna <a href=canvas.html#ie><code>explorercanvas</code></a> implementující canvas <abbr>API</abbr> do Microsoft Internet Exploreru.

<p>Funkci nemusíte psát sami, místo toho můžete použít <a href=#modernizr>Modernizr</a>, aby detekoval canvas <abbr>API</abbr> za vás.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> otestuj podporu canvasu
<pre><code>if (<mark>Modernizr.canvas</mark>) {
  // něco honem nakreslíme!
} else {
  // žádná podpora canvasu 8-(
}</code></pre>

<p>Nyní se podíváme na další test, který ověřuje podporu canvas text <abbr>API</abbr>.

<p class=a>&#x2767;

<h2 id=canvas-text>Text v canvasu</h2>

<p class=ss style="width:414px"><img src=i/openclipart.org_johnny_automatic_baseball_at_bat.png width=414 height=254 alt="baseballový hráč na pálce"><br><span id=live-canvas-text></span>

<p>I přestože váš prohlížeč podporuje <a href=#canvas>canvas <abbr>API</abbr></a>, nemusí ještě nutně podporovat <dfn>canvas text</dfn> <abbr>API</abbr>. Canvas <abbr>API</abbr> se totiž vyvíjelo a textové funkce byly přidány až později. Některé prohlížeče implementovaly canvas ještě před tím, než se objevilo text <abbr>API</abbr>.

<p>Test na canvas text <abbr>API</abbr> používá <a href=#techniques>detekční techniku #2</a>. Pokud váš prohlížeč podporuje canvas <abbr>API</abbr>, pak objekt <abbr>DOM</abbr> reprezentující vytvořený prvek <code>&lt;canvas></code> bude obsahovat <a href=canvas.html#shapes>metodu <code>getContext()</code></a>. Pokud váš pohlížeč canvas <abbr>API</abbr> nepodporuje, tak objekt <abbr>DOM</abbr> reprezentující vytvořený prvek <code>&lt;canvas></code> bude mít pouze sadu běžných vlastností, ovšem žádnou z těch specifických pro canvas.

<pre><code>function supports_canvas_text() {
  if (!supports_canvas()) { return false; }
  var dummy_canvas = document.createElement('canvas');
  var context = dummy_canvas.getContext('2d');
  return typeof context.fillText == 'function';
}</code></pre>

<p>Tato funkce nejdřív <a href=#canvas>otestuje základní podporu canvasu</a> pomocí funkce <code>supports_canvas()</code>, kterou jste viděli v předchozí sekci. Pokud váš prohlížeč nepodporuje canvas <abbr>API</abbr>, pak zcela jistě nebude podporovat ani canvas text <abbr>API</abbr>.

<pre><code>if (<mark>!supports_canvas()</mark>) { return false; }</code></pre>

<p>Dále vytvoříme prázdný prvek <code>&lt;canvas></code> a získáme jeho kreslicí kontext. To musí fungovat, protože funkce <code>supports_canvas()</code> už otestovala existenci metody <code>getContext()</code> na objektech canvasu.

<pre><code>  var dummy_canvas = document.createElement('canvas');
  var context = <mark>dummy_canvas.getContext('2d')</mark>;</code></pre>

<p>Nakonec otestujeme, zda kreslicí kontext obsahuje funkci <code>fillText()</code>. Pokud ano, tak prohlížeč podporuje canvas text <abbr>API</abbr>. Hurá!

<pre><code>  return <mark>typeof context.fillText == 'function'</mark>;</code></pre>

<p>Funkci nemusíte psát sami, místo toho můžete použít <a href=#modernizr>Modernizr</a>, aby detekoval canvas text <abbr>API</abbr> za vás.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> check for canvas text support
<pre><code>if (<mark>Modernizr.canvastext</mark>) {
  // honem něco napíšeme!
} else {
  // žádná podpora pro canvas text 8-(
}</code></pre>

<p class=a>&#x2767;

<h2 id=video>Video</h2>

<p><abbr>HTML5</abbr> definuje nový prvek <code>&lt;video></code> sloužící k vkládání videa do vašich webových stránek. Dříve bylo nemožné vložit na stránku video bez použití pluginů od třetích stran jako Apple QuickTime&reg; nebo Adobe Flash&reg;.

<p class=ss style="width:224px"><img src=i/openclipart.org_johnny_automatic_at_the_theater.png alt="diváci v divadle" width=224 height=334><br><span id=live-video></span>

<p>Prvek <code>&lt;video></code> byl navržen tak, aby byl použitelný bez jakéhokoliv detekčního skriptu. Můžete uvést několik video souborů a prohlížeče, které <abbr>HTML5</abbr> video podorují, si z nich vyberou, podle toho, jaké formáty podporují.

(Viz &#8222;A gentle introduction to video encoding&#8221; <a href=http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats>part 1: container formats</a> a <a href=http://diveintomark.org/archives/2008/12/19/give-part-2-lossy-video-codecs>part 2: lossy video codecs</a>, kde se dozvíte víc o rozličných formátech videa.)

<p>Prohlížeče, které nepodorují <abbr>HTML5</abbr> video, budou prvek <code>&lt;video></code> zcela ignorovat. Toho ovšem můžete využít a nabídnout jim místotoho k přehrání video pomocí pluginu. Kroc Camen sestavil řešení nazvané <a href=http://camendesign.com/code/video_for_everybody>Video for Everybody! (Video pro každého)</a>, které používá <abbr>HTML5</abbr> video tam, kde je to možné, a ve starších prohlížečích využije QuickTime nebo Flash. Krocovo řešení navíc nepoužívá žádný JavaScript a funguje teoreticky ve všech prohlížečích včetně mobilních.

<p>Pokud chcete s videem dělat víc, než jen ho umístit na stránku a přehrát, musíte už použít JavaScript. Test podpory videa využívá <a href=#techniques>detekční techniku #2</a>. Pokud váš prohlížeč podoruje <abbr>HTML5</abbr> video, tak objekt <abbr>DOM</abbr> reprezentující vytvořený prvek <code>&lt;video></code> bude obsahovat metodu <code>canPlayType()</code>. Pokud váš prohlížeč nepodporuje <abbr>HTML5</abbr> video, tak objekt <abbr>DOM</abbr> reprezentující vytvořený prvek <code>&lt;video></code> bude mít pouze sadu vlastností běžných pro všechny prvky HTML. Podporu videa můžete otestovat touto funkcí:

<pre><code>function supports_video() {
  return !!document.createElement('video').canPlayType;
}</code></pre>

<p>Fukci nemusíte psát sami, místo toho můžete použít <a href=#modernizr>Modernizr</a>, aby detekoval podporu <abbr>HTML5</abbr> videa za vás.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> ověř podporu <abbr>HTML5</abbr> videa
<pre><code>if (<mark>Modernizr.video</mark>) {
  // pusťme si nějaké video!
} else {
  // nativní podpora videa není dostupná 8-(
  // mohli bychom zkusit otestovat podporu QuickTime nebo Flashe
}</code></pre>

<p>V <a href=video.html>kapitole o videu</a> popíšu další řešení, které používá tyto detekční techniky pro konverzi elementů <code>&lt;video></code> na kód pro videopřehrávače postavené na Flashi, což využijí prohlížeče, které <abbr>HTML5</abbr> video nepodorují.

<p>Nyní se podíváme na test pro detekci formátů videa, které dokáže prohlížeč přehrát.

<p class=a>&#x2767;

<h2 id=video-formats>Video formáty</h2>

<p>Video formats are like written languages. An English newspaper may convey the same information as a Spanish newspaper, but if you can only read English, only one of them will be useful to you! To play a video, your browser needs to understand the &#8220;language&#8221; in which the video was written.

<p class=ss style="float:left;margin:0 1.75em 1.75em 0;width:250px"><img src=i/openclipart.org_johnny_automatic_man_reading_newspaper.png alt="man reading newspaper" width=250 height=261><br><span id=live-video-formats></span>

<p>The &#8220;language&#8221; of a video is called a &#8220;codec&#8221; &mdash; this is the algorithm used to encode the video into a stream of bits. There are dozens of codecs in use all over the world. Which one should you use? The unfortunate reality of <abbr>HTML5</abbr> video is that browsers can&#8217;t agree on a single codec. However, they seem to have narrowed it down to two. One codec costs money (because of patent licensing), but it works in <a href=http://www.apple.com/safari/>Safari</a> and on the iPhone.  (This one also works in Flash if you use a solution like <a href=http://camendesign.com/code/video_for_everybody>Video for Everybody!</a>) The other codec is free and works in open source browsers like <a href=http://code.google.com/chromium/>Chromium</a> and <a href=http://www.getfirefox.com/>Mozilla Firefox</a>.

<p>Checking for video format support uses <a href=#techniques>detection technique #3</a>. If your browser supports <abbr>HTML5</abbr> video, the <abbr>DOM</abbr> object it creates to represent a <code>&lt;video></code> element will have a <code>canPlayType()</code> method. This method will tell you whether the browser supports a particular video format.

<p>This function checks for the patent-encumbered format supported by Macs and iPhones.

<pre><code>function supports_h264_baseline_video() {
  if (!supports_video()) { return false; }
  var v = document.createElement("video");
  return v.canPlayType('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
}</code></pre>

<p>The function starts by <a href=#video>checking for <abbr>HTML5</abbr> video support</a>, using the <code>supports_video()</code> function you just saw in the previous section. If your browser doesn&#8217;t support <abbr>HTML5</abbr> video, it certainly won&#8217;t support any video formats!

<pre><code>  if (<mark>!supports_video()</mark>) { return false; }</code></pre>

<p>Then the function creates a dummy <code>&lt;video></code> element (but doesn&#8217;t attach it to the page, so it won&#8217;t be visible) and calls the <code>canPlayType()</code> method. This method is guaranteed to be there, because the <code>supports_video()</code> function just checked for it.

<pre><code>  var <mark>v</mark> = document.createElement("video");</code></pre>

<p>A &#8220;video format&#8221; is really a combination of different things. In technical terms, you&#8217;re asking the browser whether it can play H.264 Baseline video and AAC LC audio in an MPEG-4 container. (I&#8217;ll explain what all that means in <a href=video.html>the Video chapter</a>. You might also be interested in reading <a href=http://diveintomark.org/tag/give>A gentle introduction to video encoding</a>.)

<pre><code>  return v.canPlayType('<mark>video/mp4; codecs="avc1.42E01E, mp4a.40.2"</mark>');</code></pre>

<p>The <code>canPlayType()</code> function doesn&#8217;t return <code>true</code> or <code>false</code>. In recognition of how complex video formats are, the function returns a string:

<ul>
<li><code>"probably"</code> if the browser is fairly confident it can play this format
<li><code>"maybe"</code> if the browser thinks it might be able to play this format
<li><code>""</code> (an empty string) if the browser is certain it can&#8217;t play this format
</ul>

<p>This second function checks for the open video format supported by Mozilla Firefox and other open source browsers. The process is exactly the same; the only difference is the string you pass in to the <code>canPlayType()</code> function. In technical terms, you&#8217;re asking the browser whether it can play Theora video and Vorbis audio in an Ogg container.

<pre><code>function supports_ogg_theora_video() {
  if (!supports_video()) { return false; }
  var v = document.createElement("video");
  return v.canPlayType(<mark>'video/ogg; codecs="theora, vorbis"'</mark>);
}</code></pre>

<p>Finally, <a href=http://www.webmproject.org/>WebM</a> is a newly open-sourced (and non-patent-encumbered) video codec that will be included in the next version of major browsers, including Chrome, <a href=http://nightly.mozilla.org/webm/>Firefox</a>, and <a href=http://labs.opera.com/news/2010/05/19/>Opera</a>. You can use the same technique to detect support for open WebM video.

<pre><code>function supports_webm_video() {
  if (!supports_video()) { return false; }
  var v = document.createElement("video");
  return v.canPlayType(<mark>'video/webm; codecs="vp8, vorbis"'</mark>);
}</code></pre>

<p>Instead of writing this function yourself, you can use <a href=#modernizr>Modernizr</a> (1.5 or later) to detect support for different <abbr>HTML5</abbr> video formats.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> check for <abbr>HTML5</abbr> video formats
<pre><code>if (Modernizr.video) {
  // let's play some video! but what kind?
  if (<mark>Modernizr.video.webm</mark>) {
    // try WebM
  } else if (<mark>Modernizr.video.ogg</mark>) {
    // try Ogg Theora + Vorbis in an Ogg container
  } else if (<mark>Modernizr.video.h264</mark>){
    // try H.264 video + AAC audio in an MP4 container
  }
}</code></pre>

<p class=a>&#x2767;

<h2 id=storage>Local Storage</h2>

<p class=ss style="width:135px"><img src=i/openclipart.org_johnny_automatic_half_stack_of_horizontal_sections.png alt="filing cabinet with drawers of different sizes" width=135 height=341><br><span id=live-storage></span>

<p><a href=http://dev.w3.org/html5/webstorage/><abbr>HTML5</abbr> storage</a> provides a way for web sites to store information on your computer and retrieve it later. The concept is similar to cookies, but it&#8217;s designed for larger quantities of information. Cookies are limited in size, and your browser sends them back to the web server every time it requests a new page (which takes extra time and precious bandwidth). <abbr>HTML5</abbr> storage stays on your computer, and web sites can access it with JavaScript after the page is loaded.

<div class="pf clear">
<h4>Ask Professor Markup</h4>
<div class=inner>
<blockquote class=note>
<p><span>&#x261E;</span>Q: Is local storage really part of <abbr>HTML5</abbr>? Why is it in a separate specification?<br>
A: The short answer is yes, local storage is part of <abbr>HTML5</abbr>. The slightly longer answer is that local storage used to be part of the main <abbr>HTML5</abbr> specification, but it was split out into a separate specification because some people in the <abbr>HTML5</abbr> Working Group complained that <abbr>HTML5</abbr> was too big. If that sounds like slicing a pie into more pieces to reduce the total number of calories&hellip; well, welcome to the wacky world of standards.
</blockquote>
</div>
</div>

<p>Checking for <abbr>HTML5</abbr> storage support uses <a href=#techniques>detection technique #1</a>. If your browser supports <abbr>HTML5</abbr> storage, there will be a <code>localStorage</code> property on the global <code>window</code> object. If your browser doesn&#8217;t support <abbr>HTML5</abbr> storage, the <code>localStorage</code> property will be undefined. Due to an unfortunate bug in older versions of Firefox, this test will raise an exception if cookies are disabled, so the entire test is wrapped in a <code>try..catch</code> statement.

<pre><code>function supports_local_storage() {
  try {
    return 'localStorage' in window && window['localStorage'] !== null;
  } catch(e){
    return false;
  }
}</code></pre>

<p>Instead of writing this function yourself, you can use <a href=#modernizr>Modernizr</a> (1.1 or later) to detect support for <abbr>HTML5</abbr> local storage.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> check for <abbr>HTML5</abbr> local storage
<pre><code>if (<mark>Modernizr.localstorage</mark>) {
  // window.localStorage is available!
} else {
  // no native support for local storage :(
  // maybe try Gears or another third-party solution
}</code></pre>

<p>Note that JavaScript is case-sensitive. The Modernizr attribute is called <code>localstorage</code> (all lowercase), but the <abbr>DOM</abbr> property is called <code>window.localStorage</code> (mixed case).

<div class="pf clear">
<h4>Ask Professor Markup</h4>
<div class=inner>
<blockquote class=note>
<p><span>&#x261E;</span>Q: How secure is my <abbr>HTML5</abbr> storage database? Can anyone read it?<br>
A: Anyone who has physical access to your computer can probably look at (or even change) your <abbr>HTML5</abbr> storage database. Within your browser, any web site can read and modify its own values, but sites can&#8217;t access values stored by other sites. This is called a <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/origin-0.html#origin-0>same-origin restriction</a>.
</blockquote>
</div>
</div>

<p class=a>&#x2767;

<h2 id=workers>Web Workers</h2>

<p class=ss style="margin:1.75em"><span id=live-web-workers></span>

<p><a href=http://www.whatwg.org/specs/web-workers/current-work/>Web Workers</a> provide a standard way for browsers to run JavaScript in the background. With web workers, you can spawn multiple &#8220;threads&#8221; that all run at the same time, more or less. (Think of how your computer can run multiple applications at the same time, and you&#8217;re most of the way there.) These &#8220;background threads&#8221; can do complex mathematical calculations, make network requests, or access <a href=#local-storage>local storage</a> while the main web page responds to the user scrolling, clicking, or typing.

<p>Checking for web workers uses <a href=#techniques>detection technique #1</a>. If your browser supports the Web Worker <abbr>API</abbr>, there will be a <code>Worker</code> property on the global <code>window</code> object. If your browser doesn&#8217;t support the Web Worker <abbr>API</abbr>, the <code>Worker</code> property will be undefined.

<pre><code>function supports_web_workers() {
  return !!window.Worker;
}</code></pre>

<p>Instead of writing this function yourself, you can use <a href=#modernizr>Modernizr</a> (1.1 or later) to detect support for web workers.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> check for web workers
<pre><code>if (<mark>Modernizr.webworkers</mark>) {
  // window.Worker is available!
} else {
  // no native support for web workers :(
  // maybe try Gears or another third-party solution
}</code></pre>

<p>Note that JavaScript is case-sensitive. The Modernizr attribute is called <code>webworkers</code> (all lowercase), but the <abbr>DOM</abbr> object is called <code>window.Worker</code> (with a capital &#8220;W&#8221; in &#8220;Worker&#8221;).

<p class=a>&#x2767;

<h2 id=offline>Offline Web Applications</h2>

<p class=ss style="width:257px"><img src=i/openclipart.org_johnny_automatic_cabin_along_stream.png alt="cabin in the woods" width=257 height=242><br><span id=live-offline></span>

<p>Reading static web pages offline is easy: connect to the Internet, load a web page, disconnect from the Internet, drive to a secluded cabin, and read the web page at your leisure. (To save time, you may wish to skip the step about the cabin.) But what about web applications like <a href=http://mail.google.com/>Gmail</a> or <a href=http://docs.google.com/>Google Docs</a>? Thanks to <abbr>HTML5</abbr>, anyone (not just Google!) can build a web application that works offline.

<p><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html#offline>Offline web applications</a> start out as online web applications. The first time you visit an offline-enabled web site, the web server tells your browser which files it needs in order to work offline. These files can be anything &mdash; <abbr>HTML</abbr>, JavaScript, images, even <a href=#video>videos</a>. Once your browser downloads all the necessary files, you can revisit the web site even if you&#8217;re not connected to the Internet. Your browser will notice that you&#8217;re offline and use the files it has already downloaded. When you get back online, any changes you&#8217;ve made can be uploaded to the remote web server.

<p>Checking for offline support uses <a href=#techniques>detection technique #1</a>. If your browser supports offline web applications, there will be an <code>applicationCache</code> property on the global <code>window</code> object. If your browser doesn&#8217;t support offline web applications, the <code>applicationCache</code> property will be undefined. You can check for offline support with the following function:

<pre><code>function supports_offline() {
  return !!window.applicationCache;
}</code></pre>

<p>Instead of writing this function yourself, you can use <a href=#modernizr>Modernizr</a> (1.1 or later) to detect support for offline web applications.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> check for offline support
<pre><code>if (<mark>Modernizr.applicationcache</mark>) {
  // window.applicationCache is available!
} else {
  // no native support for offline :(
  // maybe try Gears or another third-party solution
}</code></pre>

<p>Note that JavaScript is case-sensitive. The Modernizr attribute is called <code>applicationcache</code> (all lowercase), but the <abbr>DOM</abbr> object is called <code>window.applicationCache</code> (mixed case).

<p class=a>&#x2767;

<h2 id=geolocation>Geolocation</h2>

<p>Geolocation is the art of figuring out where you are in the world and (optionally) sharing that information with people you trust. There is more than one way to figure out where you are &mdash; your <abbr>IP</abbr> address, your wireless network connection, which cell tower your phone is talking to, or dedicated <abbr>GPS</abbr> hardware that calculates latitude and longitude from information sent by satellites in the sky.

<p style="margin:0 auto;width:194px" id=geo-wrapper><img src=i/openclipart.org_johnny_automatic_globe_man.png alt="man with a globe for a head" width=194 height=317><br><span id=live-geolocation></span>

<div class="pf clear">
<h4>Ask Professor Markup</h4>
<div class=inner>
<blockquote class=note>
<p><span>&#x261E;</span>Q: Is geolocation part of <abbr>HTML5</abbr>? Why are you talking about it?<br>
A: Geolocation support is being added to browsers right now, along with support for new <abbr>HTML5</abbr> features. Strictly speaking, geolocation is being standardized by the <a href=http://www.w3.org/2008/geolocation/>Geolocation Working Group</a>, which is separate from the <abbr>HTML5</abbr> Working Group. But I&#8217;m going to talk about geolocation in this book anyway, because it&#8217;s part of the evolution of the web that&#8217;s happening now.
</blockquote>
</div>
</div>

<p>Checking for geolocation support uses <a href=#techniques>detection technique #1</a>. If your browser supports the geolocation <abbr>API</abbr>, there will be a <code>geolocation</code> property on the global <code>navigator</code> object. If your browser doesn&#8217;t support the geolocation <abbr>API</abbr>, the <code>geolocation</code> property will be undefined. Here&#8217;s how to check for geolocation support:

<pre><code>function supports_geolocation() {
  return !!navigator.geolocation;
}</code></pre>

<p>Instead of writing this function yourself, you can use <a href=#modernizr>Modernizr</a> to detect support for the geolocation <abbr>API</abbr>.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> check for geolocation support
<pre><code>if (<mark>Modernizr.geolocation</mark>) {
  // let's find out where you are!
} else {
  // no native geolocation support available :(
  // maybe try Gears or another third-party solution
}</code></pre>

<p>If your browser does not support the geolocation <abbr>API</abbr> natively, there is still hope. <a href=http://tools.google.com/gears/>Gears</a> is an open source browser plugin from Google that works on Windows, Mac, Linux, Windows Mobile, and Android. It provides features for older browsers that do not support all the fancy new stuff we&#8217;ve discussed in this chapter. One of the features that Gears provides is a geolocation <abbr>API</abbr>. It&#8217;s not the same as the <code>navigator.geolocation</code> <abbr>API</abbr>, but it serves the same purpose.

<p>There are also device-specific geolocation <abbr>API</abbr>s on older mobile phone platforms, including <a href="http://www.tonybunce.com/2008/05/08/Blackberry-Browser-Amp-GPS.aspx">BlackBerry</a>, <a href="http://www.forum.nokia.com/infocenter/index.jsp?topic=/Web_Developers_Library/GUID-4DDE31C7-EC0D-4EEC-BC3A-A0B0351154F8.html">Nokia</a>, <a href="http://developer.palm.com/index.php?option=com_content&amp;view=article&amp;id=1673#GPS-getCurrentPosition">Palm</a>, and <a href=http://bondi.omtp.org/1.0/apis/geolocation.html><abbr title="Open Mobile Terminal Platform">OMTP</abbr> BONDI</a>.

<p>The <a href=geolocation.html>chapter on geolocation</a> will go into excruciating detail about how to use all of these different <abbr>API</abbr>s.

<p class=a>&#x2767;

<h2 id=input-types>Input Types</h2>

<p class=ss style="width:261px"><img src=i/openclipart.org_johnny_automatic_typewriter.png alt="manual typewriter" width=261 height=228><br><span id=live-input-types></span>

<p>You know all about web forms, right? Make a <code>&lt;form></code>, add a few <code>&lt;input type="text"></code> elements and maybe an <code>&lt;input type="password"></code>, and finish it off with an <code>&lt;input type="submit"></code> button.

<p>You don&#8217;t know the half of it. <abbr>HTML5</abbr> defines over a dozen new input types that you can use in your forms.

<ol>
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#text-state-and-search-state><code>&lt;input type="search"></code></a> for search boxes
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/number-state.html#number-state><code>&lt;input type="number"></code></a> for spinboxes
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/number-state.html#range-state><code>&lt;input type="range"></code></a> for sliders
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/number-state.html#color-state><code>&lt;input type="color"></code></a> for color pickers
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#telephone-state><code>&lt;input type="tel"></code></a> for telephone numbers
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#url-state><code>&lt;input type="url"></code></a> for web addresses
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#e-mail-state><code>&lt;input type="email"></code></a> for email addresses
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#date-state><code>&lt;input type="date"></code></a> for calendar date pickers
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#month-state><code>&lt;input type="month"></code></a> for months
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#week-state><code>&lt;input type="week"></code></a> for weeks
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#time-state><code>&lt;input type="time"></code></a> for timestamps
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#date-and-time-state><code>&lt;input type="datetime"></code></a> for precise, absolute date+time stamps
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#local-date-and-time-state><code>&lt;input type="datetime-local"></code></a> for local dates and times
</ol>

<p>Checking for <abbr>HTML5</abbr> input types uses <a href=#techniques>detection technique #4</a>. First, you create a dummy <code>&lt;input></code> element in memory. The default input type for all <code>&lt;input></code> elements is <code>"text"</code>. This will prove to be vitally important.

<pre><code>  var i = document.createElement("input");</code></pre>

<p>Next, set the <code>type</code> attribute on the dummy <code>&lt;input></code> element to the input type you want to detect.

<pre><code>  i.setAttribute("type", "color");</code></pre>

<p>If your browser supports that particular input type, the <code>type</code> property will retain the value you set. If your browser doesn&#8217;t support that particular input type, it will ignore the value you set and the <code>type</code> property will still be <code>"text"</code>.

<pre><code>  return i.type !== "text";</code></pre>

<p>Instead of writing 13 separate functions yourself, you can use <a href=#modernizr>Modernizr</a> to detect support for all the new input types defined in <abbr>HTML5</abbr>. Modernizr reuses a single <code>&lt;input></code> element to efficiently detect support for all 13 input types. Then it builds a hash called <code>Modernizr.inputtypes</code>, that contains 13 keys (the <abbr>HTML5</abbr> <code>type</code> attributes) and 13 Boolean values (<code>true</code> if supported, <code>false</code> if not).

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> check for native date picker
<pre><code>if (<mark>!Modernizr.inputtypes.date</mark>) {
  // no native support for &lt;input type="date"> :(
  // maybe build one yourself with <a href=http://docs.dojocampus.org/dojox/widget/Calendar>Dojo</a> or <a href=http://jqueryui.com/demos/datepicker/>jQueryUI</a>
}</code></pre>

<p class=a>&#x2767;

<h2 id=input-placeholder>Placeholder Text</h2>

<form style="float:right;margin:1.75em"><input placeholder="Your browser supports placeholder text" size=38></form>

<p>Besides <a href=#input-types>new input types</a>, <abbr>HTML5</abbr> includes several small tweaks to existing forms. One improvement is the ability to set <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/common-input-element-attributes.html#the-placeholder-attribute>placeholder text in an input field</a>. Placeholder text is displayed inside the input field as long as the field is empty and not focused. As soon you click on (or tab to) the input field, the placeholder text disappears. The <a href=forms.html#placeholder>chapter on web forms</a> has screenshots if you&#8217;re having trouble visualizing it.

<p>Checking for placeholder support uses <a href=#techniques>detection technique #2</a>. If your browser supports placeholder text in input fields, the <abbr>DOM</abbr> object it creates to represent an <code>&lt;input></code> element will have a <code>placeholder</code> property (even if you don&#8217;t include a <code>placeholder</code> attribute in your <abbr>HTML</abbr>). If your browser doesn&#8217;t support placeholder text, the <abbr>DOM</abbr> object it creates for an <code>&lt;input></code> element will not have a <code>placeholder</code> property.

<pre><code>function supports_input_placeholder() {
  var i = document.createElement('input');
  return 'placeholder' in i;
}</code></pre>

<p>Instead of writing this function yourself, you can use <a href=#modernizr>Modernizr</a> (1.1 or later) to detect support for placeholder text.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> check for placeholder text
<pre><code>if (<mark>Modernizr.input.placeholder</mark>) {
  // your placeholder text should already be visible!
} else {
  // no placeholder support :(
  // fall back to a scripted solution
}</code></pre>

<p class=a>&#x2767;

<h2 id=input-autofocus>Form Autofocus</h2>

<p class=ss style="width:188px"><img src=i/openclipart.org_johnny_automatic_angry_guy.png alt="angry guy with arms up" width=188 height=262><br><span id="live-input-autofocus"></span>

<p>Web sites can use JavaScript to focus the first input field of a web form automatically. For example, the home page of <a href=http://www.google.com/>Google.com</a> will autofocus the input box so you can type your search keywords without having to position the cursor in the search box. While this is convenient for most people, it can be annoying for power users or people with special needs. If you press the space bar expecting to scroll the page, the page will not scroll because the focus is already in a form input field. (It types a space in the field instead of scrolling.) If you focus a different input field while the page is still loading, the site&#8217;s autofocus script may &#8220;helpfully&#8221; move the focus back to the original input field upon completion, disrupting your flow and causing you to type in the wrong place.

<p>Because the autofocusing is done with JavaScript, it can be tricky to handle all of these edge cases, and there is little recourse for people who don&#8217;t want a web page to &#8220;steal&#8221; the focus.

<p>To solve this problem, <abbr>HTML5</abbr> introduces <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/association-of-controls-and-forms.html#autofocusing-a-form-control>an <code>autofocus</code> attribute on all web form controls</a>. The <code>autofocus</code> attribute does exactly what it says on the tin: it moves the focus to a particular input field. But because it&#8217;s just markup instead of a script, the behavior will be consistent across all web sites. Also, browser vendors (or extension authors) can offer users a way to disable the autofocusing behavior.

<p>Checking for autofocus support uses <a href=#techniques>detection technique #2</a>. If your browser supports autofocusing web form controls, the <abbr>DOM</abbr> object it creates to represent an <code>&lt;input></code> element will have an <code>autofocus</code> property (even if you don&#8217;t include the <code>autofocus</code> attribute in your <abbr>HTML</abbr>). If your browser doesn&#8217;t support autofocusing web form controls, the <abbr>DOM</abbr> object it creates for an <code>&lt;input></code> element will not have an <code>autofocus</code> property. You can detect autofocus support with this function:

<pre><code>function supports_input_autofocus() {
  var i = document.createElement('input');
  return 'autofocus' in i;
}</code></pre>

<p>Instead of writing this function yourself, you can use <a href=#modernizr>Modernizr</a> (1.1 or later) to detect support for autofocused form fields.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> check for autofocus support
<pre><code>if (<mark>Modernizr.input.autofocus</mark>) {
  // autofocus works!
} else {
  // no autofocus support :(
  // fall back to a scripted solution
}</code></pre>

<p class=a>&#x2767;

<h2 id=microdata>Microdata</h2>

<p class=ss style="width:305px"><img src=i/openclipart.org_johnny_automatic_divider_cards.png alt="alphabetized folders" width=305 height=224><br><span id="live-microdata-api"></span>

<p><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/links.html#microdata>Microdata</a> is a standardized way to provide additional semantics in your web pages. For example, you can use microdata to declare that a photograph is available under a specific Creative Commons license. As you&#8217;ll see in <a href=extensibility.html>the distributed extensibility chapter</a>, you can use microdata to mark up an &#8220;About Me&#8221; page. Browsers, browser extensions, and search engines can convert your <abbr>HTML5</abbr> microdata markup into a <a href=http://en.wikipedia.org/wiki/VCard>vCard</a>, a standard format for sharing contact information. You can also define your own microdata vocabularies.

<p>The <abbr>HTML5</abbr> microdata standard includes both <abbr>HTML</abbr> markup (primarily for search engines) and a set of <abbr>DOM</abbr> functions (primarily for browsers). There&#8217;s no harm in including microdata markup in your web pages. It&#8217;s nothing more than a few well-placed attributes, and search engines that don&#8217;t understand the microdata attributes will just ignore them. But if you need to access or manipulate microdata through the <abbr>DOM</abbr>, you&#8217;ll need to check whether the browser supports the microdata <abbr>DOM</abbr> <abbr>API</abbr>.

<p>Checking for <abbr>HTML5</abbr> microdata <abbr>API</abbr> support uses <a href=#techniques>detection technique #1</a>. If your browser supports the <abbr>HTML5</abbr> microdata <abbr>API</abbr>, there will be a <code>getItems()</code> function on the global <code>document</code> object. If your browser doesn&#8217;t support microdata, the <code>getItems()</code> function will be undefined.

<pre><code>function supports_microdata_api() {
  return !!document.getItems;
}</code></pre>

<p>Modernizr does not yet support checking for the microdata <abbr>API</abbr>, so you&#8217;ll need to use the function like the one listed above.

<p class=a>&#x2767;

<h2 id=history>History <abbr>API</abbr></h2>

<p class=ss style="float:left;margin:0 1.75em 1.75em 0;width:218px"><img src=i/openclipart.org_johnny_automatic_demon_reading_Stewart_Orr.png alt="demon reading book" width=218 height=231><br><span id=live-history-api></span>

<p>The <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html><abbr>HTML5</abbr> history <abbr>API</abbr></a> is a standardized way to manipulate the browser history via script. Part of this <abbr>API</abbr> &mdash; navigating the history &mdash; has been available in previous versions of <abbr>HTML</abbr>. The new part in <abbr>HTML5</abbr> is a way to add entries to the browser history, and respond when those entries are removed from the stack by the user pressing the browser&#8217;s back button. This means that the <abbr>URL</abbr> can continue to do its job as a unique identifier for the current resource, even in script-heavy applications that don&#8217;t ever perform a full page refresh.

<p>Checking for <abbr>HTML5</abbr> history <abbr>API</abbr> support uses <a href=#techniques>detection technique #1</a>. If your browser supports the <abbr>HTML5</abbr> history <abbr>API</abbr>, there will be a <code>pushState()</code> function on the global <code>history</code> object. If your browser doesn&#8217;t support the history <abbr>API</abbr>, the <code>pushState()</code> function will be undefined.

<pre><code>function supports_history_api() {
  return !!(window.history && history.pushState);
}</code></pre>

<p>Instead of writing this function yourself, you can use <a href=#modernizr>Modernizr</a> (1.6 or later) to detect support for the <abbr>HTML5</abbr> history <abbr>API</abbr>.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> check for history <abbr>API</abbr> support
<pre><code>if (<mark>Modernizr.history</mark>) {
  // history management works!
} else {
  // no history support :(
  // fall back to a scripted solution like <a href=https://github.com/balupton/History.js/>History.js</a>
}</code></pre>

<p class=a>&#x2767;

<h2 id=further-reading>Further Reading</h2>

<p>Specifications and standards:

<ul>
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html>the <code>&lt;canvas></code> element</a>
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#video>the <code>&lt;video></code> element</a>
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#states-of-the-type-attribute><code>&lt;input></code> types</a>
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/common-input-element-attributes.html#the-placeholder-attribute>the <code>&lt;input placeholder></code> attribute</a>
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/association-of-controls-and-forms.html#autofocusing-a-form-control>the <code>&lt;input autofocus></code> attribute</a>
<li><a href=http://dev.w3.org/html5/webstorage/><abbr>HTML5</abbr> storage</a>
<li><a href=http://www.whatwg.org/specs/web-workers/current-work/>Web Workers</a>
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html#offline>Offline web applications</a>
<li><a href=http://www.w3.org/TR/geolocation-API/>Geolocation <abbr>API</abbr></a>
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html>Session history and navigation</a>
</ul>

<p>JavaScript libraries:

<ul>
<li><a href=http://www.modernizr.com/>Modernizr</a>, an <abbr>HTML5</abbr> detection library
<li><a href=http://code.google.com/p/geo-location-javascript/>geo.js</a>, a geolocation <abbr>API</abbr> wrapper
<li><a href=https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills><abbr>HTML5</abbr> Cross-browser Polyfills</a>
</ul>

<p>Other articles and tutorials:

<ul>
<li><a href=http://camendesign.com/code/video_for_everybody>Video for Everybody!</a>
<li><a href=http://diveintomark.org/tag/give>A gentle introduction to video encoding</a>
<li><a href=http://wiki.whatwg.org/wiki/Video_type_parameters>Video type parameters</a>
<li><a href=everything.html>The All-In-One Almost-Alphabetical No-Bullshit Guide to Detecting Everything</a>
<li><a href=http://msdn.microsoft.com/en-us/ie/ff468705.aspx>Internet Explorer 9 Guide for Developers</a>
</ul>

<p class=a>&#x2767;

<p>This has been &#8220;Detecting <abbr>HTML5</abbr> Features.&#8221; The <a href=table-of-contents.html>full table of contents</a> has more if you&#8217;d like to keep reading.

<div class=pf>
<h4>Did You Know?</h4>
<div class=moneybags>
<blockquote><p>In association with Google Press, O&#8217;Reilly is distributing this book in a variety of formats, including paper, ePub, Mobi, and <abbr>DRM</abbr>-free <abbr>PDF</abbr>. The paid edition is called &#8220;HTML5: Up &amp; Running,&#8221; and it is available now. This chapter is included in the paid edition.
<p>If you liked this chapter and want to show your appreciation, you can <a href="http://www.amazon.com/HTML5-Up-Running-Mark-Pilgrim/dp/0596806027?ie=UTF8&amp;tag=diveintomark-20&amp;creativeASIN=0596806027">buy &#8220;HTML5: Up &amp; Running&#8221; with this affiliate link</a> or <a href=http://oreilly.com/catalog/9780596806033>buy an electronic edition directly from O&#8217;Reilly</a>. You&#8217;ll get a book, and I&#8217;ll get a buck. I do not currently accept direct donations.
</blockquote>
</div>
</div>

<p class=c>Copyright MMIX&ndash;MMXI <a href=about.html>Mark Pilgrim</a>

<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:6jgee_nxreo><input type=hidden name=ie value=UTF-8><input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=sa value=Search></div></form>
<script src=j/jquery.js></script>
<script src=j/modernizr.js></script>
<script src=j/gears_init.js></script>
<script src=j/geo.js></script>
<script src=j/dih5.js></script>
<script src="http://maps.google.com/maps?file=api&amp;v=2&amp;sensor=false&amp;key=ABQIAAAA9KK0oCozk3pdOlGYD6hrthR5pnyo8QWLgiiZq1vJ3YhZL8oiJBQk9j0jg4PxEDmO36mYgldwXseYGw"></script>
<script>
function supports(bool, suffix) {
  var s = "Your browser ";
  if (bool) {
    s += "supports " + suffix + ".";
  } else {
    s += "does not support " + suffix + ". :(";
  }
  return s;
}
function I_CAN_HAS(result) {
  if (result == "probably") {
    return "can play";
  }
  if (result == "maybe") {
    return "isn't sure if it can play";
  }
  return "can't play";
}
function lookup_location() {
  geo_position_js.getCurrentPosition(show_map, show_map_error);
}
function show_map(loc) {
  $("#geo-wrapper").css({'width':'320px','height':'350px'});
  var map = new GMap2(document.getElementById("geo-wrapper"));
  var center = new GLatLng(loc.coords.latitude,loc.coords.longitude);	
  map.setCenter(center, 14);	
  map.addControl(new GSmallMapControl());
  map.addControl(new GMapTypeControl());
  map.addOverlay(new GMarker(center, {draggable: false, title: "You are here (more or less)"}));
}
function show_map_error() {
  $("#live-geolocation").html('Unable to determine your location.');
}
$(function() {
  $("#live-canvas").html(supports(Modernizr.canvas, "the canvas API"));
  $("#live-canvas-text").html(supports(Modernizr.canvastext, "the canvas text API"));
  $("#live-video").html(supports(Modernizr.video, "HTML5 video"));
  if (Modernizr.video) {
    var ogg = Modernizr.video.ogg;
    var h264 = Modernizr.video.h264;
    var webm = Modernizr.video.webm;
    var vf = "Your browser ";
    if ((ogg == "probably") && (h264 == "probably")) {
      vf += "can play both Ogg Theora and H.264";
    } else if (((ogg == "") || (ogg == "no")) && (h264 == "probably")) {
      vf += "can play H.264 video, but not Ogg Theora";
    } else if (((h264 == "") || (h264 == "no")) && (ogg == "probably")) {
      vf += "can play Ogg Theora video, but not H.264";
    } else {
      vf += I_CAN_HAS(ogg) + " Ogg Theora video. Your browser " + I_CAN_HAS(h264) + " H.264";
    }
    vf += " video.";
    if (webm) {
      vf += " Hey, you can play WebM video, too!";
    }
    $("#live-video-formats").html(vf);
  } else {
    $("#live-video-formats").html(supports(Modernizr.video, "any video formats"));
  }
  var localstorage = false;
  try {
    localstorage = Modernizr.localstorage;
  } catch(e) {}
  $("#live-storage").html(supports(localstorage, "HTML5 storage"));
  $("#live-web-workers").html(supports(Modernizr.webworkers, "web workers"));
  $("#live-offline").html(supports(Modernizr.applicationcache, "offline web applications"));
  if (geo_position_js.init()) {
    $("#live-geolocation").html(supports(true, "geolocation") + ' <a href="#" onclick="lookup_location();return false">Click to look up your location</a>.');
  } else {
    $("#live-geolocation").html(supports(false, "geolocation"));
  }
  var supported_input_types = '';
  for (var itype in Modernizr.inputtypes) {
    if (Modernizr.inputtypes[itype]) {
      supported_input_types += '<code>' + itype + '</code>, ';
    }
  }
  if (!!supported_input_types) {
    $("#live-input-types").html('Your browser supports the following HTML5 input types: ' + supported_input_types.replace(/, $/, ''));
  } else {
    $("#live-input-types").html('Your browser does not support any HTML5 input types.');
  }
  $("#live-input-autofocus").html(supports(!!("autofocus" in document.createElement("input")), "form autofocus"));
  $("#live-microdata-api").html(supports(!!document.getItems, "the HTML5 microdata API"));
  $("#live-history-api").html(supports(!!Modernizr.history, "the HTML5 history API"));
});
</script>
